"""
Base interfaces for AI Hedge Fund trading agents.
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass
from datetime import datetime
from enum import Enum
from typing import Dict, List, Any, Optional

import pandas as pd


class SignalDirection(Enum):
    """Trading signal direction."""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"
    SHORT = "short"
    COVER = "cover"


@dataclass
class MarketData:
    """Container for market data used by agents."""
    prices: pd.DataFrame  # Historical price data
    volumes: pd.DataFrame  # Trading volume data
    fundamentals: Optional[Dict[str, Any]] = None  # Fundamental data if available
    sentiment: Optional[Dict[str, float]] = None  # Sentiment scores if available
    technical_indicators: Optional[Dict[str, pd.DataFrame]] = None  # Technical indicators
    timestamp: datetime = datetime.now()


@dataclass
class TradeSignal:
    """Trading signal generated by an agent."""
    agent_id: str  # Unique identifier of the generating agent
    symbol: str  # Trading symbol
    direction: SignalDirection  # Signal direction
    confidence: float  # Signal confidence score (0-1)
    timestamp: datetime  # Signal generation time
    target_price: Optional[float] = None  # Target price if applicable
    stop_loss: Optional[float] = None  # Stop loss level if applicable
    metadata: Dict[str, Any] = None  # Additional signal metadata


@dataclass
class AgentMetrics:
    """Performance metrics for an agent."""
    signal_accuracy: float  # Historical signal accuracy
    profit_factor: float  # Ratio of winning to losing trades
    sharpe_ratio: float  # Risk-adjusted return metric
    max_drawdown: float  # Maximum historical drawdown
    win_rate: float  # Percentage of profitable signals
    avg_profit_per_signal: float  # Average profit per signal
    total_signals: int  # Total number of signals generated
    timestamp: datetime  # Metrics calculation time


class ITradeAgent(ABC):
    """Base interface for all trading agents."""
    
    @abstractmethod
    async def initialize(self, config: Dict[str, Any]) -> None:
        """Initialize the agent with configuration parameters."""
        pass
    
    @abstractmethod
    async def generate_signals(self, market_data: MarketData) -> List[TradeSignal]:
        """
        Generate trading signals based on market data.
        
        Args:
            market_data: Current market data including prices, volumes, etc.
            
        Returns:
            List of trading signals
        """
        pass
    
    @abstractmethod
    async def get_confidence_level(self) -> float:
        """
        Get the current confidence level of the agent.
        
        Returns:
            Confidence score between 0 and 1
        """
        pass
    
    @abstractmethod
    async def validate_signal(self, signal: TradeSignal) -> bool:
        """
        Validate a generated trading signal.
        
        Args:
            signal: Trading signal to validate
            
        Returns:
            True if signal is valid, False otherwise
        """
        pass
    
    @abstractmethod
    async def update_metrics(self, performance_data: pd.DataFrame) -> AgentMetrics:
        """
        Update agent performance metrics.
        
        Args:
            performance_data: DataFrame with signal performance data
            
        Returns:
            Updated agent metrics
        """
        pass
    
    @abstractmethod
    async def adapt_parameters(self, metrics: AgentMetrics) -> None:
        """
        Adapt agent parameters based on performance metrics.
        
        Args:
            metrics: Current agent performance metrics
        """
        pass


class BaseTradeAgent(ITradeAgent):
    """Base implementation of trade agent interface."""
    
    def __init__(self, agent_id: str, config: Dict[str, Any] = None):
        """
        Initialize base trade agent.
        
        Args:
            agent_id: Unique identifier for this agent
            config: Optional configuration parameters
        """
        self.agent_id = agent_id
        self.config = config or {}
        self.metrics: Optional[AgentMetrics] = None
        self._signal_history: List[TradeSignal] = []
        
    async def initialize(self, config: Dict[str, Any]) -> None:
        """Initialize agent with configuration."""
        self.config.update(config)
        
    async def get_confidence_level(self) -> float:
        """Get base confidence level."""
        if not self.metrics:
            return 0.5  # Default confidence
        return min(max(self.metrics.signal_accuracy, 0.0), 1.0)
        
    async def validate_signal(self, signal: TradeSignal) -> bool:
        """Basic signal validation."""
        if not signal.symbol or not signal.direction:
            return False
        if not 0 <= signal.confidence <= 1:
            return False
        return True
        
    async def update_metrics(self, performance_data: pd.DataFrame) -> AgentMetrics:
        """Update agent metrics with performance data."""
        if performance_data.empty:
            return AgentMetrics(
                signal_accuracy=0.0,
                profit_factor=0.0,
                sharpe_ratio=0.0,
                max_drawdown=0.0,
                win_rate=0.0,
                avg_profit_per_signal=0.0,
                total_signals=0,
                timestamp=datetime.now()
            )
            
        # Calculate basic metrics
        total_signals = len(performance_data)
        winning_trades = performance_data[performance_data['profit'] > 0]
        losing_trades = performance_data[performance_data['profit'] < 0]
        
        win_rate = len(winning_trades) / total_signals if total_signals > 0 else 0
        profit_factor = (
            abs(winning_trades['profit'].sum()) / abs(losing_trades['profit'].sum())
            if len(losing_trades) > 0 and losing_trades['profit'].sum() != 0
            else 0
        )
        
        # Calculate Sharpe ratio
        returns = performance_data['profit'].pct_change()
        sharpe_ratio = (
            (returns.mean() / returns.std()) * (252 ** 0.5)  # Annualized
            if len(returns) > 1 and returns.std() != 0
            else 0
        )
        
        # Calculate drawdown
        cumulative = (1 + performance_data['profit']).cumprod()
        rolling_max = cumulative.expanding().max()
        drawdowns = (cumulative - rolling_max) / rolling_max
        max_drawdown = abs(drawdowns.min()) if not drawdowns.empty else 0
        
        self.metrics = AgentMetrics(
            signal_accuracy=win_rate,
            profit_factor=profit_factor,
            sharpe_ratio=sharpe_ratio,
            max_drawdown=max_drawdown,
            win_rate=win_rate,
            avg_profit_per_signal=performance_data['profit'].mean(),
            total_signals=total_signals,
            timestamp=datetime.now()
        )
        
        return self.metrics
        
    async def adapt_parameters(self, metrics: AgentMetrics) -> None:
        """Base parameter adaptation."""
        # Store metrics for future reference
        self.metrics = metrics